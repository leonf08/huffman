1) The first step in the C compilation pipeline is preprocessing. A source file has a number of header files included. The contents of these files are gathered by the preprocessor as a single body of C code. We get a single piece of code created by copying content of the header files into the source file. Also, other preprocessor directives must be resolved in this step. This preprocessed piece of code is called a translation unit. In the next step compilator takes translation unit and produces assembly code still in human-readable format. This code is machine-dependent. Then, assembler generates object file where code is represented by machine-level instructions. Object file is not an executable file. It only contains instructions for particular translation unit. Final step is linking. It combines all the object files of a project, includes libraries, resolves references, look for definitions of functions, and, finally, produces executable object file which can be run on a target machine.
2) Syntax errors: Errors that occur when you violate the rules of writing C/C++ syntax are known as syntax errors. This compiler error indicates something that must be fixed before the code can be compiled. All these errors are detected by compiler and thus are known as compile-time errors. Linker Errors: These error occurs when after compilation we link the different object files with main’s object. These are errors generated when the executable of the program cannot be generated. This may be due to wrong function prototyping, incorrect header files. One of the most common linker error is writing Main() instead of main(). Logical Errors : On compilation and execution of a program, desired output is not obtained when certain input values are given. These types of errors which provide incorrect output but appears to be error free are called logical errors. Semantic errors : This error occurs when the statements written in the program are not meaningful to the compiler.
3)Function declaration is a prototype that specifies the function name, return types and parameters without the function body. Function Definition, on the other hand, refers to the actual function that specifies the function name, return types and parameters with the function body.
4)Function declaration indicates the compiler about a specific function. This helps to identify a function. The parameter list consists of what is passed to the function to perform the task. The return type refers to the data type of the output of the function.
5)Standard input - this is the file handle that your process reads to get information from you. The program requests data transfers by use of the read operation. Unless redirected, standard input is inherited from the parent process. In the case of an interactive shell, that is usually associated with the keyboard. Standard output - your process writes conventional output to this file handle. The program requests data transfer with the write operation. Unless redirected, standard output is inherited from the parent process. In the case of an interactive shell, that is usually the text terminal which initiated the program. Standard error - your process writes diagnostic output to this file handle. The usual destination is the text terminal which started the program to provide the best chance of being seen even if standard output is redirected (so not readily observed). For example, output of a program in a pipeline is redirected to input of the next program, but errors from each program still go directly to the text terminal.
6) When working with files, you need to declare a pointer of type file. This declaration is needed for communication between the file and the program. Opening a file is performed using the fopen() function defined in the stdio.h header file. The syntax for opening a file in standard I/O is: ptr = fopen("fileopen","mode"); The file (both text and binary) should be closed after reading/writing. Closing a file is performed using the fclose() function: fclose(fptr); For reading and writing to a text file, we use the functions fprintf() and fscanf(). They are just the file versions of printf() and scanf(). The only difference is that fprintf() and fscanf() expects a pointer to the structure FILE. Functions fread() and fwrite() are used for reading from and writing to a file on the disk respectively in case of binary files.
7) The if statement evaluates the test expression inside the parenthesis ().

If the test expression is evaluated to true, statements inside the body of if are executed.
If the test expression is evaluated to false, statements inside the body of if are not executed.
if..else operation: 
If the test expression is evaluated to true,

statements inside the body of if are executed.
statements inside the body of else are skipped from execution.
If the test expression is evaluated to false,

statements inside the body of else are executed
statements inside the body of if are skipped from execution.
switch..xase operation: 
The expression is evaluated once and compared with the values of each case label.

If there is a match, the corresponding statements after the matching label are executed. For example, if the value of the expression is equal to constant2, statements after case constant2: are executed until break is encountered.
If there is no match, the default statements are executed.
for loop: 
The initialization statement is executed only once.
Then, the test expression is evaluated. If the test expression is evaluated to false, the for loop is terminated.
However, if the test expression is evaluated to true, statements inside the body of the for loop are executed, and the update expression is updated.
Again the test expression is evaluated.
while loop: 
The while loop evaluates the testExpression inside the parentheses ().
If testExpression is true, statements inside the body of while loop are executed. Then, testExpression is evaluated again.
The process goes on until testExpression is evaluated to false.
If testExpression is false, the loop terminates (ends).
do..while operation:
The body of do...while loop is executed once. Only then, the testExpression is evaluated.
If testExpression is true, the body of the loop is executed again and testExpression is evaluated once more.
This process goes on until testExpression becomes false.
If testExpression is false, the loop ends.
8) Unary operators are those that work on single operand e.g. increment operator( ++) or the decrement operator( - - ). int a =b++; or something like int C =d- -;
Binary operators are the one that operate on two operands e.g. ‘+’, ‘ -’, ‘ *’, ‘/’. Syntax can be like int C=a+b;
Ternary operators are the one that operates on three operands. It takes three argumets . 1st argument is checked for its validity . If it is true 2nd argument is returned else third argument is returned. For example if we write int C= a>b ? e:f; now if a is greater than b 'e' is returned otherwise 'f' is returned.
9) Operators Precedence and Associativity are two characteristics of operators that determine the evaluation order of sub-expressions in absence of brackets. Operator precedence determines which operator is performed first in an expression with more than one operators with different precedence. Operators Associativity is used when two operators of same precedence appear in an expression. Associativity can be either Left to Right or Right to Left.
10) The sections of a C program:
Documentation section - It includes the statement specified at the beginning of a program, such as a program's name, date, description, and title
Preprocessor section - The preprocessor section contains all the header files used in a program
Definition section - The define section comprises of different constants declared using the define keyword
Global declaration - The global section comprises of all the global declarations in the program
Main function - main() is the first function to be executed by the computer
User defined functions - The section contains definitions of all the functions in a particular source file
11) Include guards ensures that compiler will process this file only once, no matter how many times it is included. Include guards are just series of preprocessor directives that guarantees file will only be included once.
Preprocessors used:

#ifndef: if not defined, determines if provided macros does not exists.
#define: Defines the macros.
#endif: Closes off #ifndef directive.
12) Values in C can be assigned to variables using binary and hexadecimal representation. To assign binary value to a variable '0b' notation is used. This feature was introduced in C99, but it's not standard, some compilers may not support this feature. To assign hexadecimal value to a variable '0x' notation is used.
13) char, int - data types for integer variables; float, double - data types for floating point variables; There are qualifiers such as short and long, which specify the size of the variables.
Size of char variable is 1 byte (8 bits), int variable - 2 bytes(16 bits) or 4 bytes(32 bits) depending on implementation, float variable - 4 bytes(32 bits), double variable - 8 bytes(32 bits). short int is guaranteed to be not greater than int. Most frequently short int equals to 2 bytes, long int equals to 4 bytes. Limits for integers are within range [0, 2^n - 1] for unsigned variables and [-2^(n-1), 2^(n-1)-1] for signed variables.
14) Precision loss might happen due to error in rounding up floating point number. Precise value of floating point number can't be represented by finite number of bits in computer's memory. It is important to note that due to this loss in precision, you should almost never directly compare two floating-point numbers. A better way to do it is to compare numbers with some precision epsilon. Overflow occurs when numbers exceed the maximum value that can be represented in the chosen numeric representation, say, double. Underflow occurs when a number is too small to be represented with full precision. Underflow can result in a number that is lacking full precision, or it can get mapped to zero. Gradual underflow stores numbers with less than full precision. Abrupt underflow jumps to zero. NaN is interpreted as a value that if undefined or unrepresentable. For example, zero devided by zero, square root of a negative number and etc.
15) Unsigned types are needed for representation of positive numbers. Their binary representation doesn't have separate place (bit) for storing a sign.Signed types can represent as positive numbers as negative. There is a special bit in their binary form to a store a sign. 0 denotes positive numbers, 1 - negative. 2’s complement of a number is obtained by inverting each bit of given number plus 1 to least significant bit (LSB). So, we represent positive numbers in binary form and negative numbers in 2’s complement form. There is extra bit for sign representation. If value of sign bit is 0, then number is positive and you can directly represent it in simple binary form, but if value of sign bit 1, then number is negative and you have to take 2’s complement of given binary number. You can get negative number by 2’s complement of a positive number and positive number by directly using simple binary representation. If value of most significant bit (MSB) is 1, then take 2’s complement from, else not. Therefore, in this representation, zero (0) has only one (unique) representation which is always positive. The range of 2’s complement form is from  (2(n-1))  to (2(n-1)-1).
16) Some data types like char , short int take less number of bytes than int, these data types are automatically promoted to int or unsigned int when an operation is performed on them. This is called integer promotion. For example no arithmetic calculation happens on smaller types like char, short and enum. They are first converted to int or unsigned int, and then arithmetic is done on them. If an int can represent all values of the original type, the value is converted to an int . Otherwise, it is converted to an unsigned int.
17) Declaration of a variable is for informing to the compiler the following information: name of the variable, type of value it holds and the initial value if any it takes. i.e., declaration gives details about the properties of a variable. Whereas, Definition of a variable says where the variable gets stored. i.e., memory for the variable is allocated during the definition of the variable. In C language definition and declaration for a variable takes place at the same time. i.e. there is no difference between declaration and definition. For example, consider the following declaration: int a;. Here, the information such as the variable name: a, and data type: int, which is sent to the compiler which will be stored in the data structure known as symbol table. Along with this, a memory of size 2 bytes(depending upon the type of compiler) will be allocated. Suppose, if we want to only declare variables and not to define it i.e. we do not want to allocate memory, then the following declaration can be used extern int a;.
18) Variables in C can be automatic, register, static and global. Varibles of the first three storage classes have local scope, the last one has global scope. Automatic and register variables exist while block of code, where they were created, is executed. Static variables have scope inside a module where they were defined. They are not visisble outside. Static variables have lifetime throughout the whole program. Global variables are visible and accessible everywhere in a program. They have lifetime throughout the whole program.
19) C provides six operators for bit manipulation. & - bitwise AND, | - bitwise OR, ^ - bitwise XOR, << - left shift, >> - right shift, ~ - bitwise NOT. 
20) Macros are handled by the pre-processor and are thus guaranteed to be inlined. Macros are used for short operations and it avoids function call overhead. It can be used if any short operation is being done in the program repeatedly. Function-like macros are very beneficial when the same block of code needs to be executed multiple times. Inline functions are those functions whose definition is small and can be substituted at the place where its function call is made. Basically, they are inlined with its function call. Even there is no guarantee that the function will actually be inlined. The compiler interprets the inline keyword as a mere hint or requests to substitute the code of function into its function call. 
Inline functions are similar to macros because they both are expanded at compile time, but the macros are expanded by the pre-processor, while inline functions are parsed by the compiler.
Expressions passed as arguments to inline functions are evaluated once. In some cases, expressions passed as arguments to macros can be evaluated more than once:
#include <stdio.h>

#define SQUARE(x) x*x

inline int square(int x)
{
	return x*x;
}

int main(void)
{
	int y = 3;
	int x = 3;
	
	printf("%d", SQUARE(++x));
	
	printf("\n%d", square(++y));
	
	return 0;
}
In this example, argument passed to macro will be evaluated twice so output of macro function would be like 5*5 which gives 25 while in case of inline function argument is evaluated only once so output would be 16.

Inline functions follow strict parameter type, macros don't.

21) There are four library functions provided by C standard library for memaory management and dynamic memory allocation: malloc, calloc, realloc, free.
The “malloc” or “memory allocation” method in C is used to dynamically allocate a single large block of memory with the specified size. It returns a pointer of type void which can be cast into a pointer of any form. It doesn’t Iniatialize memory at execution time so that it initializes each block with the default garbage value initially.
“calloc” or “contiguous allocation” method in C is used to dynamically allocate the specified number of blocks of memory of the specified type. it is very much similar to malloc() but has two different points and these are:
It initializes each block with a default value ‘0’.
It has two parameters or arguments as compare to malloc(). ptr = (cast-type*)calloc(n, element-size);
here, n is the no. of elements and element-size is the size of each element.
“realloc” or “re-allocation” method in C is used to dynamically change the memory allocation of a previously allocated memory. In other words, if the memory previously allocated with the help of malloc or calloc is insufficient, realloc can be used to dynamically re-allocate memory. re-allocation of memory maintains the already present value and new blocks will be initialized with the default garbage value.
If space allocated by malloc, realloc and calloc is insufficient, allocation fails and returns a NULL pointer.
“free” method in C is used to dynamically de-allocate the memory. The memory allocated using functions malloc() and calloc() is not de-allocated on their own. Hence the free() method is used, whenever the dynamic memory allocation takes place. It helps to reduce wastage of memory by freeing it.
22) NULL pointer is a specific type of pointers in C. It points to nowhere in memory, and it can't be dereferenced. Some of the most common use cases for NULL are
a) To initialize a pointer variable when that pointer variable isn’t assigned any valid memory address yet.
b) To check for a null pointer before accessing any pointer variable. By doing so, we can perform error handling in pointer related code e.g. dereference pointer variable only if it’s not NULL.
c) To pass a null pointer to a function argument when we don’t want to pass any valid memory address.
A pointer pointing to a memory location that has been deleted (or freed) is called dangling pointer. There are three different ways where Pointer acts as dangling pointer: deallocation of memory provided that the pointer is not assigned to NULL after that; The pointer pointing to local variable becomes dangling when local variable is not static; Variable goes out of scope. 
A pointer which has not been initialized to anything (not even NULL) is known as wild pointer. The pointer may be initialized to a non-NULL garbage value that may not be a valid address.
23) Static analysis, also called static code analysis, is a method of computer program debugging that is done by examining the code without executing the program. The process provides an understanding of the code structure and can help ensure that the code adheres to industry standards. Static analysis is used in software engineering by software development and quality assurance teams. Automated tools can assist programmers and developers in carrying out static analysis. The software will scan all code in a project to check for vulnerabilities while validating the code. Static analysis is generally good at finding coding issues such as:
Programming errors
Coding standard violations
Undefined values
Syntax violations
Security vulnerabilities
The static analysis process is also useful for addressing weaknesses in source code that could lead to buffer overflows -- a common software vulnerability.
Once the code is written, a static code analyzer should be run to look over the code. It will check against defined coding rules from standards or custom predefined rules. Once the code is run through the static code analyzer, the analyzer will have identified whether or not the code complies with the set rules. It is sometimes possible for the software to flag false positives, so it is important for someone to go through and dismiss any. Once false positives are waived, developers can begin to fix any apparent mistakes, generally starting from the most critical ones. Once the code issues are resolved, the code can move on to testing through execution. There are several static analysis methods an organization could use, which include:
Control analysis -- focuses on the control flow in a calling structure. For example, a control flow could be a process, function, method or in a subroutine.
Data analysis -- makes sure defined data is properly used while also making sure data objects are properly operating.
Fault/failure analysis -- analyzes faults and failures in model components.
Interface analysis -- verifies simulations to check the code and makes sure the interface fits into the model and simulation.
Benefits of using static analysis include:

It can evaluate all the code in an application, increasing code quality.
It provides speed in using automated tools compared to manual code review
Paired with normal testing methods, static testing allows for more depth into debugging code.
Automated tools are less prone to human error.
It will increase the likelihood of finding vulnerabilities in the code, increasing web or application security.
It can be done in an offline development environment.
However, static analysis comes with some drawbacks. For example, organizations should stay aware of the following:
False positives can be detected.
A tool might not indicate what the defect is if there is a defect in the code.
Not all coding rules can always be followed, like rules that need external documentation.
Static analysis may take more time than comparable methods.
Static analysis can't detect how a function will execute.
System and third-party libraries may not be able to be analyzed.
24) A structure is a user defined data type in C/C++. A structure creates a data type that can be used to group items of possibly different types into a single type. A structure variable can either be declared with structure declaration or as a separate declaration like basic types.

// A variable declaration with structure declaration.
struct Point
{
   int x, y;
} p1;  // The variable p1 is declared with 'Point'
  
  
// A variable declaration like basic data types
struct Point
{
   int x, y;
}; 
  
int main()
{
   struct Point p1;  // The variable p1 is declared like a normal variable
}
Structure members can be initialized using curly braces ‘{}’. For example, following is a valid initialization.

struct Point
{
   int x, y;
}; 
  
int main()
{
   // A valid initialization. member x gets value 0 and y
   // gets value 1.  The order of declaration is followed.
   struct Point p1 = {0, 1}; 
}
Designated Initialization allows structure members to be initialized in any order. This feature has been added in C99 standard.


#include<stdio.h>
  
struct Point
{
   int x, y, z;
};
  
int main()
{
   // Examples of initialization using designated initialization
   struct Point p1 = {.y = 0, .z = 1, .x = 2};
   struct Point p2 = {.x = 20};
  
   printf ("x = %d, y = %d, z = %d\n", p1.x, p1.y, p1.z);
   printf ("x = %d", p2.x);
   return 0;
}
Structure members are accessed using dot (.) operator.


#include<stdio.h>
  
struct Point
{
   int x, y;
};
  
int main()
{
   struct Point p1 = {0, 1};
  
   // Accessing members of point p1
   p1.x = 20;
   printf ("x = %d, y = %d", p1.x, p1.y);
  
   return 0;
}
25) Like Structures, union is a user defined data type. In union, all members share the same memory location. For example in the following C program, both x and y share the same location. If we change x, we can see the changes being reflected in y.


#include <stdio.h>
  
// Declaration of union is same as structures
union test {
    int x, y;
};
  
int main()
{
    // A union variable t
    union test t;
  
    t.x = 2; // t.y also gets value 2
    printf("After making x = 2:\n x = %d, y = %d\n\n",
           t.x, t.y);
  
    t.y = 10; // t.x is also updated to 10
    printf("After making y = 10:\n x = %d, y = %d\n\n",
           t.x, t.y);
    return 0;
}
26) In C, we can specify size (in bits) of structure and union members. The idea is to use memory efficiently when we know that the value of a field or group of fields will never exceed a limit or is withing a small range.
Following are some interesting facts about bit fields in C.
1. A special unnamed bit field of size 0 is used to force alignment on next boundary. For example consider the following program. 
 


#include <stdio.h>
 
// A structure without forced alignment
struct test1 {
    unsigned int x : 5;
    unsigned int y : 8;
};
 
// A structure with forced alignment
struct test2 {
    unsigned int x : 5;
    unsigned int : 0;
    unsigned int y : 8;
};
 
int main()
{
    printf("Size of test1 is %lu bytes\n",
           sizeof(struct test1));
    printf("Size of test2 is %lu bytes\n",
           sizeof(struct test2));
    return 0;
}
2. We cannot have pointers to bit field members as they may not start at a byte boundary. 

#include <stdio.h>
struct test {
    unsigned int x : 5;
    unsigned int y : 5;
    unsigned int z;
};
int main()
{
    struct test t;
 
    // Uncommenting the following line will make
    // the program compile and run
    printf("Address of t.x is %p", &t.x);
 
    // The below line works fine as z is not a
    // bit field member
    printf("Address of t.z is %p", &t.z);
    return 0;
}
3. It is implementation defined to assign an out-of-range value to a bit field member.

27) Padding bytes is a mechanism used by compiler to allign data of a structure in memory by adding some number of extra empty bytes. The processor does not read 1 byte at a time. It reads 1 word at a time. On 32-bit processors one word equals to 4 bytes, on 64-bit - to 8 bytes. 
struct Example {
	char a;
	int b;
}
In the example above size of a structure Example is 8 bytes due to padding. In order to allow proccesor to read one word at a time, 3 empty bytes are added after char a variable in memory. In case of no padding CPU would require 2 cycles to read b member of Example structure.
28) An array in C/C++ or be it in any programming language is a collection of similar data items stored at contiguous memory locations and elements can be accessed randomly using indices of an array.  They can be used to store collection of primitive data types such as int, float, double, char, etc of any particular type. 
// Array declaration by specifying size
int arr1[10];
 
// With recent C/C++ versions, we can also
// declare an array of user specified size
int n = 10;
int arr2[n];

// Array declaration by initializing elements
int arr[] = { 10, 20, 30, 40 }
 
// Compiler creates an array of size 4.
// above is same as  "int arr[4] = {10, 20, 30, 40}"

// Array declaration by specifying size and initializing
// elements
int arr[6] = { 10, 20, 30, 40 }
 
// Compiler creates an array of size 6, initializes first
// 4 elements as specified by user and rest two elements as
// 0. above is same as  "int arr[] = {10, 20, 30, 40, 0, 0}"

Array elements are accessed by using an integer index. Array index starts with 0 and goes till size of array minus 1. There is no index out of bounds checking in C/C++, for example, the following program compiles fine but may produce unexpected output when run.

Structure members can be initialized using curly braces ‘{}’. For example, following is a valid initialization.

struct Point
{
   int x, y;
}; 
  
int main()
{
   // A valid initialization. member x gets value 0 and y
   // gets value 1.  The order of declaration is followed.
   struct Point p1 = {0, 1}; 
}
Designated Initialization allows structure members to be initialized in any order. This feature has been added in C99 standard.
#include<stdio.h>
  
struct Point
{
   int x, y, z;
};
  
int main()
{
   // Examples of initialization using designated initialization
   struct Point p1 = {.y = 0, .z = 1, .x = 2};
   struct Point p2 = {.x = 20};
  
   printf ("x = %d, y = %d, z = %d\n", p1.x, p1.y, p1.z);
   printf ("x = %d", p2.x);
   return 0;
}
29) Pointers store address of variables or a memory location.  

// General syntax
datatype *var_name; 

// An example pointer "ptr" that holds
// address of an integer variable or holds
// address of a memory whose value(s) can
// be accessed as integer values through "ptr"
int *ptr;
To access address of a variable to a pointer, we use the unary operator & (ampersand) that returns the address of that variable. For example &x gives us address of variable x.
// The output of this program can be different
// in different runs. Note that the program
// prints address of a variable and a variable
// can be assigned different address in different
// runs.
#include <stdio.h>
 
int main()
{
    int x;
 
    // Prints address of x
    printf("%p", &x);
 
    return 0;
}
One more operator is unary * (Asterisk) which is used for two things : 
To declare a pointer variable: When a pointer variable is declared in C/C++, there must be a * before its name. 

// C program to demonstrate declaration of
// pointer variables.
#include <stdio.h>
int main()
{
    int x = 10;
 
    // 1) Since there is * in declaration, ptr
    // becomes a pointer variable (a variable
    // that stores address of another variable)
    // 2) Since there is int before *, ptr is
    // pointer to an integer type variable
    int *ptr;
 
    // & operator before x is used to get address
    // of x. The address of x is assigned to ptr.
    ptr = &x;
 
    return 0;
}

To access the value stored in the address we use the unary operator (*) that returns the value of the variable located at the address specified by its operand. This is also called Dereferencing. 

// C program to demonstrate use of * for pointers in C
#include <stdio.h>
 
int main()
{
    // A normal integer variable
    int Var = 10;
 
    // A pointer variable that holds address of var.
    int *ptr = &Var;
 
    // This line prints value at address stored in ptr.
    // Value stored is value of variable "var"
    printf("Value of Var = %d\n", *ptr);
 
    // The output of this line may be different in different
    // runs even on same machine.
    printf("Address of Var = %p\n", ptr);
 
    // We can also use ptr as lvalue (Left hand
    // side of assignment)
    *ptr = 20; // Value at address is now 20
 
    // This prints 20
    printf("After doing *ptr = 20, *ptr is %d\n", *ptr);
 
    return 0;
}
A limited set of arithmetic operations can be performed on pointers. A pointer may be:  

incremented ( ++ )
decremented ( — )
an integer may be added to a pointer ( + or += )
an integer may be subtracted from a pointer ( – or -= )
Pointer arithmetic is meaningless unless performed on an array. 
Note : Pointers contain addresses. Adding two addresses makes no sense, because there is no idea what it would point to. Subtracting two addresses lets you compute the offset between these two addresses.

30) An array name acts like a pointer constant. The value of this pointer constant is the address of the first element. 
For example, if we have an array named val then val and &val[0] can be used interchangeably.
// C program to illustrate call-by-methods
#include <stdio.h>
  
void geeks() 
{ 
    //Declare an array 
    int val[3] = { 5, 10, 20 }; 
      
    //declare pointer variable 
    int *ptr; 
      
    //Assign the address of val[0] to ptr 
    // We can use ptr=&val[0];(both are same) 
    ptr = val ; 
    printf("Elements of the array are: "); 
    printf("%d %d %d", ptr[0], ptr[1], ptr[2]); 
} 
//Driver program 
int main() 
{ 
    geeks(); 
}
Array members are accessed using pointer arithmetic. 
Compiler uses pointer arithmetic to access array element. For example, an expression like “arr[i]” is treated as *(arr + i) by the compiler. That is why the expressions like *(arr + i) work for array arr, and expressions like ptr[i] also work for pointer ptr.
#include <stdio.h>
 
int main()
{
   int arr[] = {10, 20, 30, 40, 50, 60};
   int *ptr = arr;
   printf("arr[2] = %d\n", arr[2]);
   printf("*(arr + 2) = %d\n", *(arr + 2));
   printf("ptr[2] = %d\n", ptr[2]);
   printf("*(ptr + 2) = %d\n", *(ptr + 2));
   return 0;
}
Array parameters are always passed as pointers, even when we use square brackets. 
#include <stdio.h>
 
int fun(int ptr[])
{
    int x = 10;
 
    // size of a pointer is printed
    printf("sizeof(ptr) = %d\n", (int)sizeof(*ptr));
 
    // This allowed because ptr is a pointer, not array
    ptr = &x;
 
    printf("*ptr = %d ", *ptr);
 
    return 0;
}
 
// Driver code
int main()
{
    int arr[] = { 10, 20, 30, 40, 50, 60 };
     
    // size of a array is printed
    printf("sizeof(arr) = %d\n", (int)sizeof(arr));
    fun(arr);
    return 0;
}
Most of the time, pointer and array accesses can be treated as acting the same, the major exceptions being: 

1. the sizeof operator 
o sizeof(array) returns the amount of memory used by all elements in array 
o sizeof(pointer) only returns the amount of memory used by the pointer variable itself 
2. the & operator 
o array is an alias for &array[0] and returns the address of the first element in array 
o &pointer returns the address of pointer 

3. a string literal initialization of a character array 
o char array[] = “abc” sets the first four elements in array to ‘a’, ‘b’, ‘c’, and ‘\0’ 
o char *pointer = “abc” sets pointer to the address of the “abc” string (which may be stored in read-only memory and thus unchangeable)
4. Pointer variable can be assigned a value whereas array variable cannot be.

int a[10];
int *p; 
p=a; /*legal*/
a=p; /*illegal*/ 

5. Arithmetic on pointer variable is allowed. 

p++; /*Legal*/
a++; /*illegal*/

31) We already know that a pointer points to a location in memory and thus used to store the address of variables. So, when we define a pointer to pointer. The first pointer is used to store the address of the variable. And the second pointer is used to store the address of the first pointer. That is why they are also known as double pointers. Declaring Pointer to Pointer is similar to declaring pointer in C. The difference is we have to place an additional ‘*’ before the name of pointer: int **ptr; Array of pointers can be represented by pointer to pointer. Name of a such an array would be a pointer pointed to the first element of the array which is a pointer as well. Practical example is a sentence. Sentence is an array of words, and word is an array of characters. Since a word (or string) is represented by char str[] or char *ptr_str, then a sentence (or array of words) is represented by char *sent[] or char **ptr_sent.

32) In C, like normal data pointers (int *, char *, etc), we can have pointers to functions. Following is a simple example that shows declaration and function call using function pointer.
#include <stdio.h>
// A normal function with an int parameter
// and void return type
void fun(int a)
{
	printf("Value of a is %d\n", a);
}

int main()
{
	// fun_ptr is a pointer to function fun()
	void (*fun_ptr)(int) = &fun;

	/* The above line is equivalent of following two
	void (*fun_ptr)(int);
	fun_ptr = &fun;
	*/

	// Invoking fun() using fun_ptr
	(*fun_ptr)(10);

	return 0;
}

1. Unlike normal pointers, a function pointer points to code, not data. Typically a function pointer stores the start of executable code
2. Unlike normal pointers, we do not allocate de-allocate memory using function pointers.
3. A function’s name can also be used to get functions’ address. For example, in the below program, we have removed address operator ‘&’ in assignment. We have also changed function call by removing *, the program still works.
#include <stdio.h>
// A normal function with an int parameter
// and void return type
void fun(int a)
{
	printf("Value of a is %d\n", a);
}

int main()
{
	void (*fun_ptr)(int) = fun; // & removed

	fun_ptr(10); // * removed

	return 0;
}
4. Like normal pointers, we can have an array of function pointers. Below example in point 5 shows syntax for array of pointers.
5. Function pointer can be used in place of switch case. For example, in below program, user is asked for a choice between 0 and 2 to do different tasks.
#include <stdio.h>
void add(int a, int b)
{
	printf("Addition is %d\n", a+b);
}
void subtract(int a, int b)
{
	printf("Subtraction is %d\n", a-b);
}
void multiply(int a, int b)
{
	printf("Multiplication is %d\n", a*b);
}

int main()
{
	// fun_ptr_arr is an array of function pointers
	void (*fun_ptr_arr[])(int, int) = {add, subtract, multiply};
	unsigned int ch, a = 15, b = 10;

	printf("Enter Choice: 0 for add, 1 for subtract and 2 "
			"for multiply\n");
	scanf("%d", &ch);

	if (ch > 2) return 0;

	(*fun_ptr_arr[ch])(a, b);

	return 0;
}
6. Like normal data pointers, a function pointer can be passed as an argument and can also be returned from a function.
For example, consider the following C program where wrapper() receives a void fun() as parameter and calls the passed function.
// A simple C program to show function pointers as parameter
#include <stdio.h>

// Two simple functions
void fun1() { printf("Fun1\n"); }
void fun2() { printf("Fun2\n"); }

// A function that receives a simple function
// as parameter and calls the function
void wrapper(void (*fun)())
{
	fun();
}

int main()
{
	wrapper(fun1);
	wrapper(fun2);
	return 0;
}
This point in particular is very useful in C. In C, we can use function pointers to avoid code redundancy. For example a simple qsort() function can be used to sort arrays in ascending order or descending or by any other order in case of array of structures. Not only this, with function pointers and void pointers, it is possible to use qsort for any data type.
// An example for qsort and comparator
#include <stdio.h>
#include <stdlib.h>

// A sample comparator function that is used
// for sorting an integer array in ascending order.
// To sort any array for any other data type and/or
// criteria, all we need to do is write more compare
// functions. And we can use the same qsort()
int compare (const void * a, const void * b)
{
return ( *(int*)a - *(int*)b );
}

int main ()
{
int arr[] = {10, 5, 15, 12, 90, 80};
int n = sizeof(arr)/sizeof(arr[0]), i;

qsort (arr, n, sizeof(int), compare);

for (i=0; i<n; i++)
	printf ("%d ", arr[i]);
return 0;
}
33) Strings are defined as an array of characters. The difference between a character array and a string is the string is terminated with a special character ‘\0’. Declaring a string is as simple as declaring a one-dimensional array. Below is the basic syntax for declaring a string.

char str_name[size];

In the above syntax str_name is any name given to the string variable and size is used to define the length of the string, i.e the number of characters strings will store. Please keep in mind that there is an extra terminating character which is the Null character (‘\0’) used to indicate the termination of string which differs strings from normal character arrays.
Initializing a String: A string can be initialized in different ways. We will explain this with the help of an example. Below is an example to declare a string with name as str and initialize it with “GeeksforGeeks”.

1. char str[] = "GeeksforGeeks";
2. char str[50] = "GeeksforGeeks";
3. char str[] = {'G','e','e','k','s','f','o','r','G','e','e','k','s','\0'};
4. char str[14] = {'G','e','e','k','s','f','o','r','G','e','e','k','s','\0'};

34) C supports a large number of string handling functions in the standard library "string.h".

Few commonly used string handling functions are discussed below:

Function	Work of Function
strlen()	computes string's length
strcpy()	copies a string to another
strcat()	concatenates(joins) two strings
strcmp()	compares two strings
strlwr()	converts string to lowercase
strupr()	converts string to uppercase
Strings handling functions are defined under "string.h" header file.

35) As strings are character arrays, so we can pass strings to function in a same way we pass an array to a function. Below is a sample program to do this:


// C program to illustrate how to 
// pass string to functions
#include<stdio.h>
  
void printStr(char str[])
{
    printf("String is : %s",str);
}
  
int main()
{   
    // declare and initialize string
    char str[] = "GeeksforGeeks";
      
    // print string by passing string
    // to a different function
    printStr(str);
      
    return 0;
}

36) A string literal in C is a sequence of chars, terminated by a literal zero.
char* str = "hello, world"; /* string literal */
String literals are not modifiable (and in fact may be placed in read-only memory such as .rodata). Attempting to alter their values results in undefined behaviour. Difference between char *str and char str[]:
char* str = "Hello" - str is a pointer variable, sizeof(str) = 4 bytes, str and &str are not the same, str is stored in stack and "Hello" is stored in text section of memory, str = "World" is valid operation, str++ is valid operation, str[0] = 'M' is invalid as text section is read-only.
char str[] = "Hello" - str is an array, sizeof(str) = 10 bytes, str and &str are the same, "Hello" is stored in stack, str = "World" is invalid operation, str++ is invalid operation, str[0] = 'M' is valid.

37) A wide character is a computer character datatype that generally has a size greater than the traditional 8-bit character. The increased datatype size allows for the use of larger coded character sets. In 1989, the International Organization for Standardization began work on the Universal Character Set (UCS), a multilingual character set that could be encoded using either a 16-bit (2-byte) or 32-bit (4-byte) value. These larger values required the use of a datatype larger than 8-bits to store the new character values in memory. Thus the term wide character was used to differentiate them from traditional 8-bit character datatypes. The C and C++ standard libraries include a number of facilities for dealing with wide characters and strings composed of them. The wide characters are defined using datatype wchar_t. Both C and C++ introduced fixed-size character types char16_t and char32_t in the 2011 revisions of their respective standards to provide unambiguous representation of 16-bit and 32-bit Unicode transformation formats, leaving wchar_t implementation-defined.

38) When a C program is compiled, the compiler generates object code. After generating the object code, the compiler also invokes linker. One of the main tasks for linker is to make code of library functions (eg printf(), scanf(), sqrt(), ..etc) available to your program. A linker can accomplish this task in two ways, by copying the code of library function to your object code, or by making some arrangements so that the complete code of library functions is not copied, but made available at run-time. Static Linking and Static Libraries is the result of the linker making copy of all used library functions to the executable file. Static Linking creates larger binary files, and need more space on disk and main memory. Examples of static libraries (libraries which are statically linked) are, .a files in Linux and .lib files in Windows. Following are some important points about static libraries.
1. For a static library, the actual code is extracted from the library by the linker and used to build the final executable at the point you compile/build your application.

2. Each process gets its own copy of the code and data. Where as in case of dynamic libraries it is only code shared, data is specific to each process. For static libraries memory footprints are larger. For example, if all the window system tools were statically linked, several tens of megabytes of RAM would be wasted for a typical user, and the user would be slowed down by a lot of paging.

3. Since library code is connected at compile time, the final executable has no dependencies on the library at run time i.e. no additional run-time loading costs, it means that you don’t need to carry along a copy of the library that is being used and you have everything under your control and there is no dependency.

4. In static libraries, once everything is bundled into your application, you don’t have to worry that the client will have the right library (and version) available on their system.

5. One drawback of static libraries is, for any change(up-gradation) in the static libraries, you have to recompile the main program every time.

6. One major advantage of static libraries being preferred even now “is speed”. There will be no dynamic querying of symbols in static libraries. Many production line software use static libraries even today.
Dynamic Linking doesn’t require the code to be copied, it is done by just placing name of the library in the binary file. The actual linking happens when the program is run, when both the binary file and the library are in memory. Examples of Dynamic libraries (libraries which are linked at run-time) are, .so in Linux and .dll in Windows. When we link an application against a shared library, the linker leaves some stubs (unresolved symbols) to be filled at application loading time. These stubs need to be filled by a tool called, dynamic linker at run time or at application loading time. Again loading of a library is of two types, static loading and dynamic loading. Don’t confuse between static loading vs static linking and dynamic loading vs dynamic linking.

39) Optimizing compiler tries to minimize or maximize some attributes of an executable computer program. Common requirements are to minimize a program's execution time,
memory footprint, storage size, and power consumption (the last three being popular for portable computers). Options for optimization:
1. Using inline functions, or macro-functions where it's possible and justifiable.
2. Loop unrolling. Many compilers can do this, but if not, a programmer can use this techinque on his own.
Example: 
Old code:
  for (i = 0; i < 100; i++)  
  {
      do_stuff(i);
  }
New code:
  for (i = 0; i < 100; )  
  {
      do_stuff(i); i++;
      do_stuff(i); i++;
      do_stuff(i); i++;
      do_stuff(i); i++;
      do_stuff(i); i++;
      do_stuff(i); i++;
      do_stuff(i); i++;
      do_stuff(i); i++;
      do_stuff(i); i++;
      do_stuff(i); i++;
  }
This way the test for i < 100 and the branch back up to the top of the loop only get executed 11 times rather than 101. Loop unrolling works best when the loop is executed a fixed non-prime number of times and the iteration variable is only modified in one place (aside from its initialization). If do_stuff() didn't make use of i, all the little i++'s could be replaced by a single i += 10. Re-arranging the for loop into a do-while loop can make the 11 into 10. If the loop only went to, say, five rather than 100 you could unroll the loop completely and eliminate the branching and testing entirely.
3. Loop jamming. The idea is to combine adjacent loops which loop over the same range of the same variable. Assuming nothing in the second loop indexes forward (for example array[i+3]), you can do this:

Old code:
  for (i = 0; i < MAX; i++)   /* initialize 2d array to 0's */  
      for (j = 0; j < MAX; j++)
          a[i][j] = 0.0;
  for (i = 0; i < MAX; i++)   /* put 1's along the diagonal */
      a[i][i] = 1.0;
New code:
  for (i = 0; i < MAX; i++)
  {
      for (j = 0; j < MAX; j++)
          a[i][j] = 0.0;      /* initialize 2d array to 0's */  
      a[i][i] = 1.0;          /* put 1's along the diagonal */
  }
  
40) A program loaded into memory and executing is called a process. In simple, a process is a program in execution. When a program is created then it is just some pieces of Bytes which is stored in Hard Disk as a passive entity. Then the program starts loading in memory and become an active entity, when a program is double-clicked in windows or entering the name of the executable file on the command line. (i.e. a.out or prog.exe)
TEXT
A process is more than the program code or a code segment is known as Text Section. This section of memory contains the executable instructions of a program. It also contains constants, macros and it is read-only segment to prevent accidentally modification of an instruction. It is also sharable so that the so that another process can use this whenever it is required.
DATA
Next Data Section segment of memory contains the global and static variables that are initialized by the programmer prior to the execution of a program. This segment is not read-only, as the value of the variables can be changed at the runtime.
BSS
BSS Section segment of memory contains the global and static variables that are not initialized by the programmer prior to the execution of a program. This segment is not read-only, as the value of the variables can be changed at the runtime.
HEAP
To allocate memory for variables whose size cannot be statically determined by the compiler before program execution, requested by the programmer, there is a requirement of dynamic allocation of memory which is done in heap segment. It can be only determined at run-time. It is managed via system calls to malloc, calloc, free, delete etc. An C example: malloc(2) return the starting address of the 2 BYTE block which is in heap area.
STACK
A process generally also includes the process stack, which contains temporary data i.e. function parameters, return addresses, and local variables. On the standard x86 architecture it grows downwards to lower addresses but on some other architectures it may grow the opposite direction.it is shown in the diagram that stack grows opposite direction of heap for avoiding overlapping problem. This section is committed to store all the data needed by a function call in a program.

41) What is a Thread?
A thread is a single sequence stream within in a process. Because threads have some of the properties of processes, they are sometimes called lightweight processes.

What are the differences between process and thread?
Threads are not independent of one other like processes as a result threads shares with other threads their code section, data section and OS resources like open files and signals. But, like process, a thread has its own program counter (PC), a register set, and a stack space.

A stack pointer register keeps the tracks of the top of the stack i.e., how much of the stack area using by the current process, and it is modified each time a value is “pushed” onto the stack. If the stack pointer meets the heap pointer the available free memory is depleted.

Why Multithreading?
Threads are popular way to improve application through parallelism. For example, in a browser, multiple tabs can be different threads. MS word uses multiple threads, one thread to format the text, other thread to process inputs, etc.
Threads operate faster than processes due to following reasons:
1) Thread creation is much faster.
2) Context switching between threads is much faster.
3) Threads can be terminated easily
4) Communication between threads is faster.
A deadlock occurs when the waiting process is still holding on to another resource that the first needs before it can finish. The canonical technique for deadlock avoidance is to have a lock hierarchy. Make sure that all threads acquire locks or other resources in the same order. This avoids the deadlock scenario where thread 1 hold lock A and needs lock B while thread 2 holds lock B and needs lock A. With a lock hierarchy, both threads would have to acquire the locks in the same order (say, A before B).
A race condition occurs when two or more threads can access shared data and they try to change it at the same time. Because the thread scheduling algorithm can swap between threads at any time, you don't know the order in which the threads will attempt to access the shared data. Therefore, the result of the change in data is dependent on the thread scheduling algorithm, i.e. both threads are "racing" to access/change the data. In order to prevent race conditions from occurring, you would typically put a lock around the shared data to ensure only one thread can access the data at a time. Mutex techinque is used for that.

42) In our computer’s memory, stack size is limited. If a program uses more memory space than the stack size then stack overflow will occur and can result in a program crash. There are two cases in which stack overflow can occur:

If we declare large number of local variables or declare an array or matrix or any higher dimensional array of large size can result in overflow of stack.

// C program to demonstrate stack overflow
// by allocating a large local memory
#include<stdio.h>
  
int main() {
  
   // Creating a matrix of size 10^5 x 10^5
   // which may result in stack overflow.
   int mat[100000][100000];
}

If function recursively call itself infinite times then the stack is unable to store large number of local variables used by every function call and will result in overflow of stack.
// C program to demonstrate stack overflow
// by creating a non-terminating recursive
// function.
#include<stdio.h>
  
void fun(int x)
{
    if (x == 1)
       return;
    x = 6;
    fun(x);
}
  
int main()
{
   int x = 5;
   fun(x);
}

Memory leak occurs when programmers create a memory in heap and forget to delete it. 

The consequences of memory leak is that it reduces the performance of the computer by reducing the amount of available memory. Eventually, in the worst case, too much of the available memory may become allocated and all or part of the system or device stops working correctly, the application fails, or the system slows down vastly.

/* Function with memory leak */
#include <stdlib.h>
 
void f()
{
   int *ptr = (int *) malloc(sizeof(int));
 
   /* Do some work */
 
   return; /* Return without freeing ptr*/
}

To avoid memory leaks, memory allocated on heap should always be freed when no longer needed.

/* Function without memory leak */
#include <stdlib.h>;
 
void f()
{
   int *ptr = (int *) malloc(sizeof(int));
 
   /* Do some work */
 
   free(ptr);
   return;
}

Failures related to invalid memory access could be referred as Segmentation Fault. The following are some typical causes of a segmentation fault:

Attempting to access a nonexistent memory address (outside process's address space)
Attempting to access memory the program does not have rights to (such as kernel structures in process context)
Attempting to write read-only memory (such as code segment)

In C code, segmentation faults most often occur because of errors in pointer use, particularly in C dynamic memory allocation. Dereferencing a null pointer will always result in a segmentation fault, but wild pointers and dangling pointers point to memory that may or may not exist, and may or may not be readable or writable, and thus can result in transient bugs.

1. Writing to read-only memory. Writing to read-only memory raises a segmentation fault. At the level of code errors, this occurs when the program writes to part of its own code segment or the read-only portion of the data segment, as these are loaded by the OS into read-only memory.
int main(void)
{
    char *s = "hello world";
    *s = 'H';
}
2. Dereferencing NULL pointer. Dereferencing a null pointer is undefined behavior in C, and a conforming implementation is allowed to assume that any pointer that is dereferenced is not null.

int *ptr = NULL;
printf("%d", *ptr);

This sample code creates a null pointer, and then tries to access its value (read the value). Doing so causes a segmentation fault at runtime on many operating systems. Dereferencing a null pointer and then assigning to it (writing a value to a non-existent target) also usually causes a segmentation fault:

int *ptr = NULL;
*ptr = 1;

3. Buffer overflow. The following code accesses the character array s beyond its upper boundary. Depending on the compiler and the processor, this may result in a segmentation fault.

char s[] = "hello world";
char c = s[20];

43) When we run a code, sometimes we see absurd results instead of expected output. So, in C/C++ programming, undefined behavior means when the program fails to compile, or it may execute incorrectly, either crashes or generates incorrect results, or when it may fortuitously do exactly what the programmer intended. Whenever the result of an executing program is unpredictable, it is said to have undefined behavior.
Examples:
Division By Zero

int val = 5;
return val / 0; // undefined behavior

Memory accesses outside of array bounds

int arr[4] = {0, 1, 2, 3};
return arr[5];  // undefined behavior for indexing out of bounds

Signed integer overflow

int x = INT_MAX;
printf("%d", x + 1);     // undefined behavior

Null pointer dereference

int *ptr = NULL;
printf("%d", *ptr);        // undefined behavior for dereferencing a null pointer

In C and C++, the relational comparison of pointers to objects (for less-than or greater-than comparison) is only strictly defined if the pointers point to members of the same object, or elements of the same array.[13] Example:

int main(void)
{
  int a = 0;
  int b = 0;
  return &a < &b; /* undefined behavior */
}

Reaching the end of a value-returning function (other than main()) without a return statement results in undefined behavior if the value of the function call is used by the caller:[14]

int f()
{
}  /* undefined behavior if the value of the function call is used*/

When modifying an object between two sequence points, reading the value of the object for any other purpose than determining the value to be stored is also undefined behavior.[19]

a[i] = i++; // undefined behavior
printf("%d %d\n", ++n, power(2, n)); // also undefined behavior

In C/C++ bitwise shifting a value by a number of bits which is either a negative number or is greater than or equal to the total number of bits in this value results in undefined behavior. The safest way (regardless of compiler vendor) is to always keep the number of bits to shift (the right operand of the << and >> bitwise operators) within the range: <0, sizeof(value)*CHAR_BIT - 1> (where value is the left operand).

int num = -1;
unsigned int val = 1 << num; //shifting by a negative number - undefined behavior

num = 32; //or whatever number greater than 31
val = 1 << num; //the literal '1' is typed as a 32-bit integer - in this case shifting by more than 31 bits is undefined behavior

num = 64; //or whatever number greater than 63
unsigned long long val2 = 1ULL << num; //the literal '1ULL' is typed as a 64-bit integer - in this case shifting by more than 63 bits is undefined behavior

Risks and Disadvantages of Undefined Behavior 

The programmers sometimes rely on a particular implementation (or compiler) of undefined behavior which may cause problems when the compiler is changed/upgraded.
Undefined behaviors may also cause security vulnerabilities, especially due to the cases when an array out of bound is not checked (causes buffer overflow attack).

Advantages of Undefined Behavior 

C and C++ have undefined behaviors because it allows compilers to avoid lots of checks. Suppose a set of code with a greater performing array need not keep a look at the bounds, which avoids the need for a complex optimization pass to check such conditions outside loops. The tightly bound loops and speed up the program from thirty to fifty percent when it gains an advantage of the undefined nature of signed overflow, which is generally offered by the C compiler.
We also have another advantage of this as it allows us to store a variable’s value in a processor register and manipulate it over time that is larger than the variable in the source code.

44) The definition of implementation-defined behavior in C is when something is left for the compiler to decide, and the compiler documents which choice it made. Example: int i = 0; i >> 3, final value of i is implementation-defined. Another example is an attempt to allocate memory of size 0. If the size of the space requested is zero, the behavior is implementation-defined: either a null pointer is returned, or the behavior is as if the size were some nonzero value, except that the returned pointer shall not be used to access an object.

45) Unspecified behaviour is defined in ISO C99 in section 3.4.4, as behavior where [the standard] provides two or more possibilities and imposes no further requirements on which is chosen in any instance. An example of unspecified behavior is the order in which the arguments to a function are evaluated.

46)C99 features.
inline: C99 adds the keyword inline which is applicable to functions. If we write inline datatype function_name (param) to any function it means that we are specifying the compiler to optimize calls to that function i.e. the function’s code will be expanded inline rather than called.

restrict: restrict is a type qualifier applicable only for pointers. A pointer qualified by restrict is initially the only means by which the object it points to can be accessed. Access to the object by another pointer can occur only if the second pointer is based on the first.
We use restrict qualifier to restrict access to the object. These are primarily used as function parameters or in malloc(). The restrict qualifier never changes the semantics of the program.

_Bool Datatype: _Bool datatype was added in C99 standard which stores 0 and 1 values. _Bool is an integer type.
Note: bool keyword in C++ and _Bool in C are different.

_Bool is used rarely instead C99 defines a new header file stdbool.h which defines three macros bool, true and false.

_Complex: C99 adds support for performing operations on complex numbers through _Complex and _Imaginary keywords. These keywords provide better support for numerical programming.

Addition of Type Qualifiers: Another important aspect added in C99 is the introduction of long long and unsigned long long type modifiers. A long long int has a range of –(2^63 – 1) to +(2^63 –1). An Unsigned long long int has a minimal range starting from 0 to +(2^64 –1). This long long type allows 64-bit integers to support as a built-in type.

Changes in Arrays: C99 added two important features to arrays:
 - Variable Length Arrays: In C89 standard, the array size has to be specified using integer constants at the array declaration and array size is fixed at compile time. In C99 standard, we can declare an array whose dimensions are specified by any integer expressions whose values known at run-time. This is called Variable Length Arrays(VLA).
 - Inclusion of Type Qualifiers: In C99, we can use the keyword static inside the square brackets during array declaration. This is only applied when array is declared in function parameters i.e
 
Single Line Comments: Single Line comments aren’t accepted in C89 standard. C99 standard introduces Single Line Comments which are used only when brief remarks are needed. These comments begin with // and runs to the end of the line.
// First Comment
int a; // another comment

Declaration of Identifiers:
According to the C89 standard, all Identifiers should be declared at the start of the code block. If we need any other identifier at the middle, we can’t declare for that instance or time. We need to declare that at the start. C99 has changed this rule as we can declare identifiers whenever we need in a code.
In simple, we can see this as:

#include <stdio.h>
int main()
{
    int i;
    i = 1;
    int j; // this declaration is invalid in C89 standard, but valid in C99 and C++
    j = 3;
}

Compound literal. Compound literals feature allows us to create unnamed objects with given list of initialized values. In the below example, an array is created without any name. Address of first element of array is assigned to pointer p. Compound literals are mainly used with structures and are particularly useful when passing structures variables to functions. We can pass a structure object without defining it

#include <stdio.h>
int main()
{
   // Compound literal (an array is created without
   // any name and address of first element is assigned
   // to p.  This is equivalent to:
   // int arr[] = {2, 4, 6};
   // int *p = arr;
   int *p = (int []){2, 4, 6};
  
   printf("%d %d %d", p[0], p[1], p[2]);
  
   return 0;
}

47) Multithreading support. The new C11 header file <threads.h> declares functions for creating and managing threads, mutexes, condition variables, and the _Atomic type qualifier. Another new header file, <stdatomic.h>, declares facilities for uninterruptible objects access. Finally, C11 introduces a new storage class specifier, _Thread_local (the C equivalent of C++11's thread_local). A variable declared _Thread_local isn't shared by multiple threads. Rather, every thread gets a unique copy thereof.
Anonymous structs and unions. An anonymous struct or union is one that has neither a tag name nor a typedef name. It's useful for nesting aggregates, e.g., a union member of a struct. The following C11 code declares a struct with an anonymous union and accesses the union's data member directly:

struct T //C++, C11
{

int m;

union //anonymous

{

  char * index;

  int key;

};

};

struct T t;

t.key=1300; //access the union's member directly

Type-Generic Functions
C11 doesn't have templates yet but it does have a macro-based method of defining type-generic functions. The new keyword _Generic declares a generic expression that translates into type-dependent "specializations."

In the following example, the generic cubic root calculation macro cbrt(X) evaluates to the specializations cbrtl(long double), cbrtf(float) and the default cbrt(double), depending on the actual type of the parameter X:

//C11 only
#define cbrt(X) _Generic((X), long double: cbrtl, 

                              default: cbrt, 

                              float: cbrtf)(X)

How does it work? The parameter X translates into the specific type of the function argument. The compiler then selects the matching variant of cbrt(): cbrtl() if X is long double, cbrtf() for float, and cbrt() otherwise.

Memory Alignment Control
Taking after C++11, C11 introduces facilities for probing and enforcing the memory alignment of variables and types. The _Alignas keyword specifies the requested alignment for a type or an object. The alignof operator reports the alignment of its operand. Finally, the aligned_alloc() function.

void *aligned_alloc(size_t algn, size_t size);
allocates size bytes of memory with alignment algn and returns a pointer to the allocated memory.

The alignment features of C11 are declared in the new header file <stdalign.h>.

The _Noreturn Function Specifier
_Noreturn declares a function that does not return. This new functions specifier has two purposes: suppressing compiler warnings on a function that doesn't return, and enabling certain optimizations that are allowed only on functions that don't return.

_Noreturn void func (); //C11, func never returns

Static Assertions
Unlike the #if and #error preprocessor directives, static assertions are evaluated at a later translation phase, when the type of the expression is known. Therefore, static assertions let you catch errors that are impossible to detect during the preprocessing phase.

Unicode Support
The Unicode standard defines three encoding formats: UTF-8, UTF-16, and UTF-32. Each has advantages and disadvantages. Currently, programmers use char to encode UTF-8, unsigned short or wchar_t for UTF-16, and unsigned long or wchar_t for UTF-32. C11 eliminates these hacks by introducing two new datatypes with platform-independent widths: char16_t and char32_t for UTF-16 and UTF-32, respectively (UTF-8 encoding uses char, as before). C11 also provides u and U prefixes for Unicode strings, and the u8 prefix for UTF-8 encoded literals. Finally, Unicode conversion functions are declared in <uchar.h>.

Static Assertions
Unlike the #if and #error preprocessor directives, static assertions are evaluated at a later translation phase, when the type of the expression is known. Therefore, static assertions let you catch errors that are impossible to detect during the preprocessing phase.
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>

int main(void)
{
  _Static_assert(sizeof(int) == 2, "Expecting 16 bit integers");
}

//Compilation error:
// error: static assertion failed: "Expecting 16 bit integers"
//    7 |   _Static_assert(sizeof(int) == 2, "Expecting 16 bit integers");
//      |   ^~~~~~~~~~~~~~

Bounds-Checking Functions
Technical Report 24731-1, which is now an integral part of C11, defines bounds-checking versions of standard C library string manipulation functions. The bounds-checking versions have the _s suffix appended to the original function names.

For example, the bounds-checking versions of strcat() and strncpy() are strcat_s() and strncpy_s(), respectively. Most of the bounds-checking functions take an additional parameter indicating the size of the buffer they process. Many of them also perform additional runtime checks to detect various runtime exceptions.

Let's look at two famous string manipulation functions:

//C11, safe version of strcat
errno_t strcat_s(char * restrict s1, 

                 rsize_t s1max, 

                 const char * restrict s2);

strcat_s() copies no more than s1max bytes to s1. The second function, strcpy_s() requires that s1max should be bigger than the length of s2 (more precisely, s1max should be be greater than strnlen_s(s2, s1max)) in order to prevent an out-of-bounds write::

//C11, safe version of strcpy
errno_t strcpy_s(char * restrict s1, 

                rsize_t s1max, 

                const char * restrict s2);

Originally, all of the bounds-checking libraries were developed by Microsoft's Visual C++ team. The C11 implementation is similar but not identical.

48) The first requirement for mixing code is that the C and C++ compilers you are using must be compatible. They must, for example, define basic types such as int, float or pointer in the same way.

Including C Headers in C++ Code
If you want to use a C library with its own defining header that was intended for C compilers, you can include the header in extern "C" brackets:
extern "C" {
    #include "header.h"

}

Creating Mixed-Language Headers
If you want to make a header suitable for both C and C++ compilers, you could put all the declarations inside extern "C" brackets, but the C compiler does not recognize the syntax. Every C++ compiler predefines the macro __cplusplus, so you can use that macro to guard the C++ syntax extensions:
#ifdef __cplusplus
extern "C" {
#endif

... // body of header

#ifdef __cplusplus
} // closing brace for extern "C"

#endif

Accessing C++ Code from Within C Source
If you declare a C++ function to have C linkage, it can be called from a function compiled by the C compiler. A function declared to have C linkage can use all the features of C++, but its parameters and return type must be accessible from C if you want to call it from C code. For example, if a function is declared to take a reference to an IOstream class as a parameter, there is no (portable) way to explain the parameter type to a C compiler. The C language does not have references or templates or classes with C++ features.

Here is an example of a C++ function with C linkage:
#include <iostream>
extern "C" int print(int i, double d)
{
    std::cout << "i = " << i << ", d = " << d;
}
You can declare function print in a header file that is shared by C and C++ code:
#ifdef __cplusplus
extern "C"
#endif
int print(int i, double d);
int print(int i, double d);

49) “Setjump” and “Longjump” are defined in setjmp.h, a header file in C standard library. 
setjump(jmp_buf buf) : uses buf to remember current position and returns 0.
longjump(jmp_buf buf, i) : Go back to place buf is pointing to and return i.
// A simple C program to demonstrate working of setjmp() and longjmp()
#include<stdio.h>
#include<setjmp.h>
jmp_buf buf;
void func()
{
	printf("Welcome to GeeksforGeeks\n");

	// Jump to the point setup by setjmp
	longjmp(buf, 1);

	printf("Geek2\n");
}

int main()
{
	// Setup jump position using buf and return 0
	if (setjmp(buf))
		printf("Geek3\n");
	else
	{
		printf("Geek4\n");
		func();
	}
	return 0;
}
The main feature of these function is to provide a way that deviates from standard call and return sequence. This is mainly used to implement exception handling in C. setjmp can be used like try (in languages like C++ and Java). The call to longjmp can be used like throw (Note that longjmp() transfers control to the point set by setjmp()).

50) In computer programming and computer science, "maximal munch" or "longest match" is the principle that when creating some construct, as much of the available input as possible should be consumed. The first phase of any compiler is to read the source program, and convert it into tokens after removing any white space and comments. The tokens are used by the parser. This process of converting the input stream into tokens is called Lexical Analysis or scanning. Compilers usually create token from the longest lexeme e.g. in case of >> in C++ compiler create token of shift right operator rather than two greater than operators. This is also called Maximum Munch Tokenization Principle, or simply Maximum Munch Principle, that the C++ implementation has to consider as many characters as possible to create token.
Other examples of the Maximum Munch Principle can be seen with digraphs. Take a look at the following code.

std::list<::x> lst;
Here <: is a digraph symbol and treated as [. So the above code is compiled as
std::list[:x> lst;

So you have to put an extra space between < and the colon. The correct code is written as
std::list< ::x> lst;

And the same is true in the following example.
int x = y%::z;
Here %: is again a digraph and considered to be # and this statement becomes
int x = y#:z;

You have to put extra space here too to compile it correctly.
int x = y % ::z;

51) digraphs and trigraphs are multi-character sequences treated by the C preprocessor and/or compiler as other (normally single-character) sequences.

Trigraphs are the earlier variant, and are defined as three-character sequences (hence tri-graph). Trigraphs are handled by the preprocessor, which means that the C compiler never actually sees them.

There are 9 standard trigraphs in C:
Trigraph  |  Converts To
----------------------------
    ??=    |  # (hash)
    ??/    |  \ (backslash)
    ??'    |  ^ (carat)
    ??(    |  [ (l. bracket)
    ??)    |  ] (r. bracket)
    ??!    |  | (bar)
    ??<    |  { (l. brace)
    ??>    |  } (r. brace)
    ??-    |  ~ (tilde)

Digraphs were introduced later and included formally in the C99 standard. As their name suggests, they consist of two-character sequences each. Unlike their older counterparts, digraphs are ignored by the preprocessor and tokenized by the compiler instead.

There are 5 standard digraphs:
Digraph  |   Converts To
--------------------------
   <:    |   [ (l. bracket)
   :>    |   ] (r. bracket)
   <%    |   { (l. brace)
   %>    |   } (r. brace)
   %:    |   # (hash)
   
Why do they exist?
Back when keyboards were unstandardized and character codes were insane, many programmers found that they (literally) lacked the symbols they needed to write programs in foreign languages ported to their systems. As such, digraphs and trigraphs were used whenever the system or hardware was incapable of composing the “correct” character. Digraphs and trigraphs are an interesting vestige of earlier times, but they aren’t very useful to the average programmer these days*.

52) The Standard Function Library in C is a huge library of sub-libraries, each of which contains the code for several functions. In order to make use of these libraries, link each library in the broader library through the use of header files. The definitions of these functions are present in their respective header files. In order to use these functions, we have to include the header file in the program. Below are some header files with descriptions:

S No.	Header Files	Description
1	<assert.h>	It checks the value of an expression that we expect to be true under normal circumstances.
If the expression is a nonzero value, the assert macro does nothing.
2	<complex.h>	 A set of functions for manipulating complex numbers.
3	<float.h>	Defines macro constants specifying the implementation-specific properties of the
floating-point library.
4	<limits.h>	These limits specify that a variable cannot store any value beyond these limits, for example-
An unsigned character can store up to a maximum value of 255.
5	<math.h>	The math.h header defines various mathematical functions and one macro. All the Functions 
in this library take double as an argument and return double as the result.
6	<stdio.h>	The stdio.h header defines three variable types, several macros, and various
function for performing input and output.
7	<time.h>	Defines date and time handling functions.
8	<string.h>	Strings are defined as an array of characters. The difference between a character array 
and a string is that a string is terminated with a special character ‘\0’.
9   <stdlib.h>  General utility functions

53) A linked list is a linear data structure, in which the elements are not stored at contiguous memory locations. In simple words, a linked list consists of nodes where each node contains a data field and a reference(link) to the next node in the list.

struct Node {
	int data;
	struct Node *next;
};

Arrays can be used to store linear data of similar types, but arrays have the following limitations. 
1) The size of the arrays is fixed: So we must know the upper limit on the number of elements in advance. Also, generally, the allocated memory is equal to the upper limit irrespective of the usage. 
2) Inserting a new element in an array of elements is expensive because the room has to be created for the new elements and to create room existing elements have to be shifted. 
For example, in a system, if we maintain a sorted list of IDs in an array id[]. 
id[] = [1000, 1010, 1050, 2000, 2040]. 
And if we want to insert a new ID 1005, then to maintain the sorted order, we have to move all the elements after 1000 (excluding 1000). 
Deletion is also expensive with arrays until unless some special techniques are used. For example, to delete 1010 in id[], everything after 1010 has to be moved.
Advantages over arrays 
1) Dynamic size 
2) Ease of insertion/deletion
Drawbacks: 
1) Random access is not allowed. We have to access elements sequentially starting from the first node. So we cannot do binary search with linked lists efficiently with its default implementation. Read about it here. 
2) Extra memory space for a pointer is required with each element of the list. 
3) Not cache friendly. Since array elements are contiguous locations, there is locality of reference which is not there in case of linked lists.
Representation: 
A linked list is represented by a pointer to the first node of the linked list. The first node is called the head. If the linked list is empty, then the value of the head is NULL. 
Each node in a list consists of at least two parts: 
1) data 
2) Pointer (Or Reference) to the next node

Applications of linked list in computer science –

Implementation of stacks and queues
Implementation of graphs : Adjacency list representation of graphs is most popular which uses linked list to store adjacent vertices.
Images are linked with each other. So, an image viewer software uses a linked list to view the previous and the next images using the previous and next buttons.
Web pages can be accessed using the previous and the next URL links which are linked using linked list.
The music players also use the same technique to switch between music.
To keep the track of turns in a multi player game, a circular linked list is used. 

Applications of the arrays are: 

Arrangement of leader-board of a game can be done simply through arrays to store the score and arrange them in descending order to clearly make out the rank of each player in the game.
A simple question Paper is an array of numbered questions with each of them assigned to some marks.
2D arrays, commonly known as, matrix, are used in image processing.
It is also used in speech processing, in which each speech signal is an array.

54) A Doubly Linked List (DLL) contains an extra pointer, typically called previous pointer, together with next pointer and data which are there in singly linked list.

/* Node of a doubly linked list */
struct Node {
    int data;
    struct Node* next; // Pointer to next node in DLL
    struct Node* prev; // Pointer to previous node in DLL
};

Advantages Of DLL:

Reversing the doubly linked list is very easy.
It can allocate or reallocate memory easily during its execution.
As with a singly linked list, it is the easiest data structure to implement.
The traversal of this doubly linked list is bidirectional which is not possible in a singly linked list.
Deletion of nodes is easy as compared to a Singly Linked List. A singly linked list deletion requires a pointer to the node and previous node to be deleted but in the doubly linked list, it only required the pointer which is to be deleted.
Disadvantages Of DLL:

It uses extra memory when compared to the array and singly linked list.
Since elements in memory are stored randomly, therefore the elements are accessed sequentially no direct access is allowed.
Uses Of DLL:

It is used in the navigation systems where front and back navigation is required.
It is used by the browser to implement backward and forward navigation of visited web pages that is a back and forward button.
It is also used to represent a classic game deck of cards.
It is also used by various applications to implement undo and redo functionality.
Doubly Linked List is also used in constructing MRU/LRU (Most/least recently used) cache.
Other data structures like stacks, Hash Tables, Binary trees can also be constructed or programmed using a doubly-linked list.
Also in many operating systems, the thread scheduler(the thing that chooses what process needs to run at which time) maintains a doubly-linked list of all processes running at that time.

55) Stack is a linear data structure which follows a particular order in which the operations are performed. The order may be LIFO(Last In First Out) or FILO(First In Last Out). 
Push: Adds an item in the stack. If the stack is full, then it is said to be an Overflow condition.
Pop: Removes an item from the stack. The items are popped in the reversed order in which they are pushed. If the stack is empty, then it is said to be an Underflow condition.
Peek or Top: Returns the top element of the stack.
isEmpty: Returns true if the stack is empty, else false.

Time Complexities of operations on stack:
push(), pop(), isEmpty() and peek() all take O(1) time. We do not run any loop in any of these operations.

There are two ways to implement a stack: 
Using array
Using linked list

// C program for array implementation of stack
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>

// A structure to represent a stack
struct Stack {
	int top;
	unsigned capacity;
	int* array;
};

// function to create a stack of given capacity. It initializes size of
// stack as 0
struct Stack* createStack(unsigned capacity)
{
	struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
	stack->capacity = capacity;
	stack->top = -1;
	stack->array = (int*)malloc(stack->capacity * sizeof(int));
	return stack;
}

// Stack is full when top is equal to the last index
int isFull(struct Stack* stack)
{
	return stack->top == stack->capacity - 1;
}

// Stack is empty when top is equal to -1
int isEmpty(struct Stack* stack)
{
	return stack->top == -1;
}

// Function to add an item to stack. It increases top by 1
void push(struct Stack* stack, int item)
{
	if (isFull(stack))
		return;
	stack->array[++stack->top] = item;
	printf("%d pushed to stack\n", item);
}

// Function to remove an item from stack. It decreases top by 1
int pop(struct Stack* stack)
{
	if (isEmpty(stack))
		return INT_MIN;
	return stack->array[stack->top--];
}

// Function to return the top from stack without removing it
int peek(struct Stack* stack)
{
	if (isEmpty(stack))
		return INT_MIN;
	return stack->array[stack->top];
}

// Driver program to test above functions
int main()
{
	struct Stack* stack = createStack(100);

	push(stack, 10);
	push(stack, 20);
	push(stack, 30);

	printf("%d popped from stack\n", pop(stack));

	return 0;
}

56) Like Stack, Queue is a linear structure which follows a particular order in which the operations are performed. The order is First In First Out (FIFO).  A good example of queue is any queue of consumers for a resource where the consumer that came first is served first. 
The difference between stacks and queues is in removing. In a stack we remove the item the most recently added; in a queue, we remove the item the least recently added.
Operations on Queue: 
Mainly the following four basic operations are performed on queue:
Enqueue: Adds an item to the queue. If the queue is full, then it is said to be an Overflow condition. 
Dequeue: Removes an item from the queue. The items are popped in the same order in which they are pushed. If the queue is empty, then it is said to be an Underflow condition. 
Front: Get the front item from queue. 
Rear: Get the last item from queue.
 
// C program for array implementation of queue
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>

// A structure to represent a queue
struct Queue {
	int front, rear, size;
	unsigned capacity;
	int* array;
};

// function to create a queue
// of given capacity.
// It initializes size of queue as 0
struct Queue* createQueue(unsigned capacity)
{
	struct Queue* queue = (struct Queue*)malloc(
		sizeof(struct Queue));
	queue->capacity = capacity;
	queue->front = queue->size = 0;

	// This is important, see the enqueue
	queue->rear = capacity - 1;
	queue->array = (int*)malloc(
		queue->capacity * sizeof(int));
	return queue;
}

// Queue is full when size becomes
// equal to the capacity
int isFull(struct Queue* queue)
{
	return (queue->size == queue->capacity);
}

// Queue is empty when size is 0
int isEmpty(struct Queue* queue)
{
	return (queue->size == 0);
}

// Function to add an item to the queue.
// It changes rear and size
void enqueue(struct Queue* queue, int item)
{
	if (isFull(queue))
		return;
	queue->rear = (queue->rear + 1)
				% queue->capacity;
	queue->array[queue->rear] = item;
	queue->size = queue->size + 1;
	printf("%d enqueued to queue\n", item);
}

// Function to remove an item from queue.
// It changes front and size
int dequeue(struct Queue* queue)
{
	if (isEmpty(queue))
		return INT_MIN;
	int item = queue->array[queue->front];
	queue->front = (queue->front + 1)
				% queue->capacity;
	queue->size = queue->size - 1;
	return item;
}

// Function to get front of queue
int front(struct Queue* queue)
{
	if (isEmpty(queue))
		return INT_MIN;
	return queue->array[queue->front];
}

// Function to get rear of queue
int rear(struct Queue* queue)
{
	if (isEmpty(queue))
		return INT_MIN;
	return queue->array[queue->rear];
}

// Driver program to test above functions./
int main()
{
	struct Queue* queue = createQueue(1000);

	enqueue(queue, 10);
	enqueue(queue, 20);
	enqueue(queue, 30);
	enqueue(queue, 40);

	printf("%d dequeued from queue\n\n",
		dequeue(queue));

	printf("Front item is %d\n", front(queue));
	printf("Rear item is %d\n", rear(queue));

	return 0;
}

// A C program to demonstrate linked list based implementation of queue
#include <stdio.h>
#include <stdlib.h>

// A linked list (LL) node to store a queue entry
struct QNode {
	int key;
	struct QNode* next;
};

// The queue, front stores the front node of LL and rear stores the
// last node of LL
struct Queue {
	struct QNode *front, *rear;
};

// A utility function to create a new linked list node.
struct QNode* newNode(int k)
{
	struct QNode* temp = (struct QNode*)malloc(sizeof(struct QNode));
	temp->key = k;
	temp->next = NULL;
	return temp;
}

// A utility function to create an empty queue
struct Queue* createQueue()
{
	struct Queue* q = (struct Queue*)malloc(sizeof(struct Queue));
	q->front = q->rear = NULL;
	return q;
}

// The function to add a key k to q
void enQueue(struct Queue* q, int k)
{
	// Create a new LL node
	struct QNode* temp = newNode(k);

	// If queue is empty, then new node is front and rear both
	if (q->rear == NULL) {
		q->front = q->rear = temp;
		return;
	}

	// Add the new node at the end of queue and change rear
	q->rear->next = temp;
	q->rear = temp;
}

// Function to remove a key from given queue q
void deQueue(struct Queue* q)
{
	// If queue is empty, return NULL.
	if (q->front == NULL)
		return;

	// Store previous front and move front one node ahead
	struct QNode* temp = q->front;

	q->front = q->front->next;

	// If front becomes NULL, then change rear also as NULL
	if (q->front == NULL)
		q->rear = NULL;

	free(temp);
}

// Driver Program to test anove functions
int main()
{
	struct Queue* q = createQueue();
	enQueue(q, 10);
	enQueue(q, 20);
	deQueue(q);
	deQueue(q);
	enQueue(q, 30);
	enQueue(q, 40);
	enQueue(q, 50);
	deQueue(q);
	printf("Queue Front : %d \n", q->front->key);
	printf("Queue Rear : %d", q->rear->key);
	return 0;
}

57) Hash Table is a data structure which stores data in an associative manner. In hash table, the data is stored in an array format where each data value has its own unique index value. Access of data becomes very fast, if we know the index of the desired data. 

58) Unlike Arrays, Linked Lists, Stack, and queues, which are linear data structures, trees are hierarchical data structures. 
A binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child. It is implemented mainly using Links. Binary Tree Representation: A tree is represented by a pointer to the topmost node in the tree. If the tree is empty, then the value of the root is NULL. A Binary Tree node contains the following parts. 
1. Data 
2. Pointer to left child 
3. Pointer to the right child

59) We can express algorithmic complexity using the big-O notation. For a problem of size N:
A constant-time function/method is “order 1” : O(1)
A linear-time function/method is “order N” : O(N)
A quadratic-time function/method is “order N squared” : O(N 2 )

In computer science, big O notation is used to classify algorithms according to how their run time or space requirements grow as the input size grows. 

60) Time complexity of some sorting algorithms:
Selection Sort  O(n^2)
Bubble Sort		O(n^2)
Insertion Sort	O(n^2)
Quick Sort		O(n^2)

